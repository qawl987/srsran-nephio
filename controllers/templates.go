/*
Copyright 2024 The Nephio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"bytes"
	"fmt"
	"text/template"

	srsranov1alpha1 "github.com/nephio-project/srsran-operator/api/v1alpha1"
)

// ─────────────────────────────────────────────────────────────────────────────
// QoS ConfigMap template
//
// Exactly six 5QI profiles are supported (ETSI TS 23.501 Table 5.7.4-1):
//
//  5QI  | Slice | PDCP DiscardTimer | RLC Mode | Scheduler priority
//  -----+-------+-------------------+----------+--------------------
//  9    | eMBB  | 300 ms            | AM       | 20  (default bearer)
//  7    | eMBB  | 100 ms            | UM       | 60
//  10   | eMBB  | 100 ms            | UM       | 50
//  82   | URLLC | 100 ms            | AM       | 160
//  84   | URLLC | 10 ms             | UM       | 230
//  85   | URLLC | 10 ms             | UM       | 250 (mission-critical)
// ─────────────────────────────────────────────────────────────────────────────

// qosProfile holds the per-5QI radio parameters that feed the QoS template.
type qosProfile struct {
	FiveQI             int
	SliceType          srsranov1alpha1.SliceType
	PDCPDiscardTimerMs int    // 0 means "infinity" (no discard)
	RLCMode            string // "AM" or "UM"
	SchedulerPriority  int    // 0–255; higher = first scheduled
	PFfairnessCoeff    float64
	PDBEnabled         bool
	GBREnabled         bool
}

// fiveQIProfiles maps 5QI → qosProfile.
// Only six 5QIs are supported: eMBB {9, 7, 10} and URLLC {82, 84, 85}.
// Unknown 5QIs fall back to 5QI=9 (eMBB default bearer).
var fiveQIProfiles = map[int]qosProfile{
	// ── eMBB ──
	9:  {9, srsranov1alpha1.SliceTypeMBB, 300, "AM", 20, 5.0, false, false},
	7:  {7, srsranov1alpha1.SliceTypeMBB, 100, "UM", 60, 3.0, false, false},
	10: {10, srsranov1alpha1.SliceTypeMBB, 100, "UM", 50, 3.5, false, false},
	// ── URLLC ──
	82: {82, srsranov1alpha1.SliceTypeURLLC, 100, "AM", 160, 2.0, false, true},
	84: {84, srsranov1alpha1.SliceTypeURLLC, 10, "UM", 230, 1.0, true, true},
	85: {85, srsranov1alpha1.SliceTypeURLLC, 10, "UM", 250, 1.0, true, true},
}

// qosTemplateSource is the Go template that produces the qos.yaml file
// mounted into the DU pod. The DU reads this at startup to configure its
// PDCP/RLC and scheduler settings per slice.
const qosTemplateSource = `# Auto-generated by srsran-operator – DO NOT EDIT
# 5QI: {{ .FiveQI }} | Slice: {{ .SliceType }}
qos:
  five_qi: {{ .FiveQI }}
  slice_type: "{{ .SliceType }}"

  pdcp:
    discard_timer_ms: {{ .PDCPDiscardTimerMs }}  # 0 = infinity (never discard)
    rlc_mode: "{{ .RLCMode }}"                   # AM = acknowledged, UM = unacknowledged

  scheduler:
    priority: {{ .SchedulerPriority }}           # 0-255; higher value = scheduled first
    pf_fairness_coeff: {{ .PFfairnessCoeff }}    # Proportional Fair coefficient
    pdb_enabled: {{ .PDBEnabled }}               # Packet Delay Budget enforcement
    gbr_enabled: {{ .GBREnabled }}               # Guaranteed Bit Rate scheduling
{{- if eq .RLCMode "UM" }}

  # Latency-optimised settings for UM (Unacknowledged Mode) – suitable for
  # URLLC / real-time traffic where retransmission would add unacceptable delay.
  rlc:
    sn_field_length: 6
    t_reassembly_ms: 40
{{- else }}

  # Reliability-optimised settings for AM (Acknowledged Mode) – suitable for
  # eMBB / mMTC traffic where guaranteed delivery matters more than latency.
  rlc:
    sn_field_length: 18
    t_poll_retransmit_ms: 45
    t_reassembly_ms: 35
    t_status_prohibit_ms: 0
{{- end }}
`

var qosTemplate = template.Must(template.New("qos").Parse(qosTemplateSource))

// renderQoSConfigMap generates the content of the qos.yaml file for the given
// SliceIntent. Unknown 5QIs fall back to the eMBB / 5QI=9 defaults.
func renderQoSConfigMap(intent srsranov1alpha1.SliceIntent) (string, error) {
	profile, ok := fiveQIProfiles[intent.FiveQI]
	if !ok {
		// Unknown 5QI → use default eMBB profile and log a warning.
		profile = fiveQIProfiles[9]
		profile.FiveQI = intent.FiveQI // keep the original value for documentation
	}
	var buf bytes.Buffer
	if err := qosTemplate.Execute(&buf, profile); err != nil {
		return "", fmt.Errorf("renderQoSConfigMap: %w", err)
	}
	return buf.String(), nil
}

// ─────────────────────────────────────────────────────────────────────────────
// DU (gNB) configuration template
// ─────────────────────────────────────────────────────────────────────────────

// CUCPConfigValues holds the dynamic values injected into the CU-CP config.
// All addresses are real routed IPs injected by Nephio IPAM – never loopback.
type CUCPConfigValues struct {
	N2BindAddr  string // NGAP bind address on N2 interface (CU-CP ↔ AMF)
	AMFAddr     string // AMF NGAP address (gateway hint from N2 IPAM)
	E1BindAddr  string // E1AP server bind address (CU-CP ↔ CU-UP)
	F1CBindAddr string // F1-AP server bind address (CU-CP ↔ DU)
	PLMN        string // 5-digit PLMN (MCC+MNC)
	TAC         int    // Tracking Area Code
}

// CUUPConfigValues holds the dynamic values injected into the CU-UP config.
// All addresses are real routed IPs injected by Nephio IPAM – never loopback.
type CUUPConfigValues struct {
	E1CUCPAddr  string // CU-CP Service DNS for E1AP client connection
	E1BindAddr  string // E1AP client bind address on E1 interface
	N3BindAddr  string // GTP-U bind address on N3 interface (CU-UP ↔ UPF)
	F1UBindAddr string // F1-U GTP-U bind address on F1U interface (CU-UP ↔ DU)
}

// DUConfigValues holds the dynamic values injected into the DU config template.
type DUConfigValues struct {
	F1CUCPAddr  string                    // CU-CP Service DNS for F1-AP client
	F1CBindAddr string                    // DU F1-AP (control) bind address
	F1UBindAddr string                    // DU F1-U (user plane) bind address
	ZMQTarget   string                    // DNS of the ZMQ peer (UE or RadioBreaker)
	ZMQTXPort   int                       // ZMQ TX port on the target
	ZMQRXPort   int                       // ZMQ RX port on the target
	PLMN        string                    // 5-digit PLMN (MCC+MNC)
	TAC         int                       // Tracking Area Code
	SliceType   srsranov1alpha1.SliceType // Used to choose scheduler policy
}

const cucpConfigTemplateSource = `# Auto-generated by srsran-operator – DO NOT EDIT
# CU-CP: N2={{ .N2BindAddr }} E1={{ .E1BindAddr }} F1C={{ .F1CBindAddr }}

cu_cp:
  amf:
    addr:      {{ .AMFAddr }}
    bind_addr: {{ .N2BindAddr }}
  e1ap:
    bind_addr: {{ .E1BindAddr }}
  f1ap:
    bind_addr: {{ .F1CBindAddr }}
  cell_cfg:
    plmn: "{{ .PLMN }}"
    tac:  {{ .TAC }}

log:
  filename: /tmp/cu_cp.log
  all_level: info

pcap:
  n2_enable: false
  e1ap_enable: false
  f1ap_enable: false
`

var cucpConfigTemplate = template.Must(template.New("cu-cp-config").Parse(cucpConfigTemplateSource))

// renderCUCPConfig renders the srsRAN CU-CP YAML configuration.
func renderCUCPConfig(v CUCPConfigValues) (string, error) {
	var buf bytes.Buffer
	if err := cucpConfigTemplate.Execute(&buf, v); err != nil {
		return "", fmt.Errorf("renderCUCPConfig: %w", err)
	}
	return buf.String(), nil
}

const cuupConfigTemplateSource = `# Auto-generated by srsran-operator – DO NOT EDIT
# CU-UP: E1CUCPAddr={{ .E1CUCPAddr }} E1={{ .E1BindAddr }} N3={{ .N3BindAddr }} F1U={{ .F1UBindAddr }}

cu_up:
  e1ap:
    cu_cp_addr: {{ .E1CUCPAddr }}
    bind_addr:  {{ .E1BindAddr }}
  ngu:
    bind_addr: {{ .N3BindAddr }}
  f1u:
    socket:
      - bind_addr: {{ .F1UBindAddr }}

log:
  filename: /tmp/cu_up.log
  all_level: info

pcap:
  e1ap_enable: false
  f1u_enable: false
  n3_enable: false
`

var cuupConfigTemplate = template.Must(template.New("cu-up-config").Parse(cuupConfigTemplateSource))

// renderCUUPConfig renders the srsRAN CU-UP YAML configuration.
func renderCUUPConfig(v CUUPConfigValues) (string, error) {
	var buf bytes.Buffer
	if err := cuupConfigTemplate.Execute(&buf, v); err != nil {
		return "", fmt.Errorf("renderCUUPConfig: %w", err)
	}
	return buf.String(), nil
}

const duConfigTemplateSource = `# Auto-generated by srsran-operator – DO NOT EDIT
# Slice: {{ .SliceType }}

f1ap:
  cu_cp_addr: {{ .F1CUCPAddr }}
  bind_addr:  {{ .F1CBindAddr }}

f1u:
  socket:
    - bind_addr: {{ .F1UBindAddr }}

ru_sdr:
  device_driver: zmq
  device_args: >-
    tx_port=tcp://{{ .ZMQTarget }}:{{ .ZMQTXPort }},
    rx_port=tcp://{{ .ZMQTarget }}:{{ .ZMQRXPort }},
    base_srate=11.52e6,
    verbose
  srate: 11.52
  tx_gain: 75
  rx_gain: 75

cell_cfg:
  dl_arfcn: 368500
  band: 3
  channel_bandwidth_MHz: 10
  common_scs: 15
  plmn: "{{ .PLMN }}"
  tac: {{ .TAC }}
  pci: 1
  scheduler:
    policy:
      qos_sched:
{{- if eq .SliceType "URLLC" }}
        pf_fairness_coeff: 1.0
        prio_enabled: true
        pdb_enabled: true
        gbr_enabled: true
{{- else }}
        # eMBB defaults
        pf_fairness_coeff: 2.0
        prio_enabled: true
        pdb_enabled: false
        gbr_enabled: false
{{- end }}
  pdcch:
    common:
      ss0_index: 0
      coreset0_index: 6
    dedicated:
      ss2_type: common
      dci_format_0_1_and_1_1: false
  prach:
    prach_config_index: 1
    total_nof_ra_preambles: 64
    nof_cb_preambles_per_ssb: 64
  pdsch:
    mcs_table: qam64
  pusch:
    mcs_table: qam64

  # Additional QoS parameters are mounted via /srsran/qos/qos.yaml
  # and applied at runtime by the DU configuration loader.

log:
  filename: /tmp/du.log
  all_level: info

pcap:
  mac_enable: false
  f1ap_enable: false
  f1u_enable: false
`

var duConfigTemplate = template.Must(template.New("du-config").Parse(duConfigTemplateSource))

// renderDUConfig renders the srsRAN gnb/DU YAML configuration.
func renderDUConfig(v DUConfigValues) (string, error) {
	var buf bytes.Buffer
	if err := duConfigTemplate.Execute(&buf, v); err != nil {
		return "", fmt.Errorf("renderDUConfig: %w", err)
	}
	return buf.String(), nil
}

// ─────────────────────────────────────────────────────────────────────────────
// srsUE configuration template
// ─────────────────────────────────────────────────────────────────────────────

// UEConfigValues holds the dynamic values injected into the srsUE config.
type UEConfigValues struct {
	ZMQTarget string // IP/hostname of the DU or RadioBreaker
	ZMQTXPort int    // UE TX → DU/RB RX port
	ZMQRXPort int    // UE RX ← DU/RB TX port
	PLMN      string // 5-digit PLMN (must match gNB)
	FiveQI    int    // Informational – stored in the config for traceability
}

const ueConfigTemplateSource = `# Auto-generated by srsran-operator – DO NOT EDIT
# ZMQ target: {{ .ZMQTarget }}:{{ .ZMQTXPort }}/{{ .ZMQRXPort }}

[rf]
freq_offset = 0
tx_gain     = 80
rx_gain     = 40
srate       = 11.52e6
device_name = zmq
device_args = tx_port=tcp://{{ .ZMQTarget }}:{{ .ZMQTXPort }},rx_port=tcp://{{ .ZMQTarget }}:{{ .ZMQRXPort }},base_srate=11.52e6

[rat.eutra]
dl_earfcn = 2850
nof_carriers = 0

[rat.nr]
bands = 3
nof_carriers = 1

[usim]
mode  = soft
algo  = milenage
opc   = 63BFA50EE6523365FF14C1F45F88737D
k     = 00112233445566778899AABBCCDDEEFF
imsi  = 208930000000001
imei  = 356938035643803

[rrc]
release = 15
ue_category = 4

[nas]
apn = internet
apn_protocol = ipv4

[log]
filename    = /tmp/ue.log
all_level   = info

[pcap]
enable    = false
filename  = /tmp/ue.pcap
`

var ueConfigTemplate = template.Must(template.New("ue-config").Parse(ueConfigTemplateSource))

// renderUEConfig renders the srsUE INI-style configuration.
func renderUEConfig(v UEConfigValues) (string, error) {
	var buf bytes.Buffer
	if err := ueConfigTemplate.Execute(&buf, v); err != nil {
		return "", fmt.Errorf("renderUEConfig: %w", err)
	}
	return buf.String(), nil
}
