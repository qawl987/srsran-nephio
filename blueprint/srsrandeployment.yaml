apiVersion: workload.nephio.org/v1alpha1
kind: SrsRanDeployment
metadata:
  # The name is updated by apply-replacements-owner.yaml to include the cluster
  # name suffix (e.g. "srsran-regional").
  name: srsran-example
  namespace: srsran-example
  annotations:
    # Nephio uses this annotation to understand which specializer should own
    # this resource during the package specialization phase.
    specializer.nephio.org/profile: ran
spec:
  # ─── Slice Intent ───────────────────────────────────────────────────────────
  # Declare what kind of RAN slice this package should implement.
  # The operator will read fiveQI and map it to PDCP/RLC/scheduler parameters
  # via its internal 5QI profile table.
  sliceIntent:
    # Slice category: eMBB | URLLC
    type: eMBB
    # 5G QoS Identifier – only the following six values are supported:
    #   eMBB:  9 (default bearer), 7 (real-time video), 10 (video buffered)
    #   URLLC: 82, 84, 85 (mission-critical / low-latency)
    fiveQI: 9
    # Optional hints – used for documentation and future capacity planning.
    maxLatencyMs: "300ms"
    uplinkBandwidth: "20M"
    downlinkBandwidth: "50M"

  # ─── Topology ───────────────────────────────────────────────────────────────
  topology:
    # ueCount = 1 → single-UE topology (direct DU ↔ UE ZMQ)
    # ueCount > 1 → multi-UE topology (DU ↔ RadioBreaker ↔ N×UE)
    ueCount: 1
    # Override auto-detection if needed: "single" | "multi"
    # type: single
    plmn: "20893"
    tac: 1

  # ─── Interfaces ─────────────────────────────────────────────────────────────
  # These fields are intentionally LEFT EMPTY here.
  # The Nephio interface-fn KRM function will read the companion interface-*.yaml
  # files and inject real IP addresses (CIDR format) into these fields
  # during package specialization, before the operator reconciles.
  #
  # Interface → Pod mapping:
  #   n2   → CU-CP  (NGAP control plane to AMF, vpc-ran)
  #   n3   → CU-UP  (GTP-U user plane to UPF, vpc-ran)
  #   e1   → CU-CP + CU-UP  (E1AP inter-CU, vpc-internal)
  #   f1c  → CU-CP + DU  (F1-AP control, vpc-internal)
  #   f1u  → CU-UP + DU  (F1-U user plane, vpc-internal)
  interfaces:
    n2:
      name: n2
      # ipAddress: ""   ← filled by interface-fn at specialization time
      # gateway: ""     ← filled by interface-fn at specialization time
    n3:
      name: n3
      # ipAddress: ""   ← filled by interface-fn at specialization time
    e1:
      name: e1
      # ipAddress: ""   ← filled by interface-fn at specialization time
    f1c:
      name: f1c
      # ipAddress: ""   ← filled by interface-fn at specialization time
    f1u:
      name: f1u
      # ipAddress: ""   ← filled by interface-fn at specialization time

  # ─── Container Images ────────────────────────────────────────────────────
  # Images are built locally via `make build-image` / `make build-ue-image`
  # and imported into microk8s with `make import` / `make import-ue`.
  # imagePullPolicy is IfNotPresent so kubelet uses the local image store.
  cucpImage:         "qawl987/srsran-split:latest"
  cuupImage:         "qawl987/srsran-split:latest"
  duImage:           "qawl987/srsran-split:latest"
  ueImage:           "qawl987/srsran-ue:latest"
  radioBreakerImage: "qawl987/srsran-ue:latest"
